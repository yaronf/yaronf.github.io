<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://www.sheffer.org/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.sheffer.org/blog/" rel="alternate" type="text/html" /><updated>2024-10-12T01:20:18+03:00</updated><id>https://www.sheffer.org/blog/feed.xml</id><title type="html">Yaron’s Blog</title><subtitle>Turns out, it&apos;s easier to self-host your rarely published blog than to rely on commercial sites and risk them going poof. So here&apos;s me giving it a try.</subtitle><author><name>Yaron Sheffer</name></author><entry><title type="html">A new RFC Published: The GNAP Core Protocol</title><link href="https://www.sheffer.org/blog/ietf/gnap/2024/10/09/GNAP.html" rel="alternate" type="text/html" title="A new RFC Published: The GNAP Core Protocol" /><published>2024-10-09T11:00:18+03:00</published><updated>2024-10-09T11:00:18+03:00</updated><id>https://www.sheffer.org/blog/ietf/gnap/2024/10/09/GNAP</id><content type="html" xml:base="https://www.sheffer.org/blog/ietf/gnap/2024/10/09/GNAP.html"><![CDATA[<p>The GNAP Core protocol has just been published as <a href="https://www.rfc-editor.org/rfc/rfc9635.html">RFC 9635</a>. The protocol has been in the works for 5 years, four of them within the <a href="https://datatracker.ietf.org/wg/gnap/about/">GNAP Working Group</a> of the IETF, which I co-chaired with Leif Johansson. I am very proud of the final product.</p>

<p>The GNAP RFC establishes a flexible framework for managing access rights between different parties. It streamlines the process of requesting, granting, and managing authorization, enabling greater adaptability and control in diverse environments. By introducing standardized interactions and data structures, GNAP facilitates seamless communication between clients seeking access and authorization servers responsible for granting it. This versatile protocol supports various authorization models and grant types, offering the flexibility to accommodate a wide range of use cases and security requirements.</p>

<p>While <a href="https://en.wikipedia.org/wiki/OAuth">OAuth</a> remains deeply entrenched in the authorization ecosystem, GNAP offers several key advantages, some of which have been subsequently adopted by OAuth. These advantages include:</p>

<ul>
  <li><strong>Flexibility:</strong> GNAP is designed to be more flexible than OAuth 2.0, allowing for a wider range of authorization models and grant types. This makes it more adaptable to different use cases and security requirements.</li>
  <li><strong>Fine-grained Access Control:</strong> GNAP introduces the concept of “resource access rights” (RAR), enabling more precise control over access to resources compared to OAuth 2.0’s scope-based approach.</li>
  <li><strong>Enhanced Client Identification:</strong> GNAP utilizes client keys for identification and communication security, offering a more robust alternative to OAuth 2.0’s reliance on client secrets and redirect URIs.</li>
  <li><strong>Versatile Interaction Models:</strong> GNAP supports more flexible interaction models, including continuous authorization and user-mediated interactions, exceeding the capabilities of OAuth 2.0’s predefined grant types.</li>
</ul>

<p>I extend my gratitude to the authors, Justin Richer and Fabian Imbault, my co-chair Leif Johansson, and the former and current Area Directors, Roman Danyliw and Deb Cooley, for their invaluable contributions.</p>

<p>With the GNAP <a href="https://datatracker.ietf.org/doc/draft-ietf-gnap-resource-servers/">Resource Server protocol</a> nearing publication, the working group will soon conclude its activities. While GNAP’s adoption has been gradual, it has already influenced OAuth and inspired several implementations. As often happens with emerging technologies, GNAP may yet find its niche within the diverse landscape of identity and access management.</p>]]></content><author><name>Yaron Sheffer</name></author><category term="ietf" /><category term="gnap" /><summary type="html"><![CDATA[The GNAP Core protocol has just been published as RFC 9635. The protocol has been in the works for 5 years, four of them within the GNAP Working Group of the IETF, which I co-chaired with Leif Johansson. I am very proud of the final product.]]></summary></entry><entry><title type="html">HTTP Message Signatures in Go, by the Book</title><link href="https://www.sheffer.org/blog/ietf/http/signatures/2024/06/23/Message-Sig.html" rel="alternate" type="text/html" title="HTTP Message Signatures in Go, by the Book" /><published>2024-06-23T11:00:18+03:00</published><updated>2024-06-23T11:00:18+03:00</updated><id>https://www.sheffer.org/blog/ietf/http/signatures/2024/06/23/Message-Sig</id><content type="html" xml:base="https://www.sheffer.org/blog/ietf/http/signatures/2024/06/23/Message-Sig.html"><![CDATA[<p>There are many good reasons to sign HTTP messages, to ensure authenticity and integrity of HTTP service calls (a.k.a. REST APIs). Now that <a href="https://datatracker.ietf.org/doc/html/rfc9421">RFC 9421</a> is finally published, we can expect many people to migrate from <a href="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">provisional</a> and <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html">proprietary</a> solutions into the standard.</p>

<p>My <a href="https://github.com/yaronf/httpsign">Go (Golang) implementation</a> covers nearly the entire RFC, and has been tested with all the test vectors that are sprinkled all across the standard. The package is also reasonably <a href="https://pkg.go.dev/github.com/yaronf/httpsign">well documented</a>, with a number of examples included. It is early days for the standard - and for the Go package - so let me know if you find the library useful. And definitely let me know if something is not working right!</p>

<p>There’s a large community of people working now on <a href="https://datatracker.ietf.org/wg/wimse/about/">service-to-service authentication</a>, which just happens to be a natural use of HTTP Message Signatures. I hope my package is put to good use in securing service infrastructure.</p>]]></content><author><name>Yaron Sheffer</name></author><category term="ietf" /><category term="HTTP" /><category term="Signatures" /><summary type="html"><![CDATA[There are many good reasons to sign HTTP messages, to ensure authenticity and integrity of HTTP service calls (a.k.a. REST APIs). Now that RFC 9421 is finally published, we can expect many people to migrate from provisional and proprietary solutions into the standard.]]></summary></entry><entry><title type="html">Just Published: A New Version of the TLS Guidelines</title><link href="https://www.sheffer.org/blog/ietf/tls/2022/11/30/TLS-BCP.html" rel="alternate" type="text/html" title="Just Published: A New Version of the TLS Guidelines" /><published>2022-11-30T10:00:18+02:00</published><updated>2022-11-30T10:00:18+02:00</updated><id>https://www.sheffer.org/blog/ietf/tls/2022/11/30/TLS-BCP</id><content type="html" xml:base="https://www.sheffer.org/blog/ietf/tls/2022/11/30/TLS-BCP.html"><![CDATA[<h2 id="yaron-sheffer-peter-saint-andre-and-thomas-fossati">Yaron Sheffer, Peter Saint-Andre and Thomas Fossati</h2>

<p><em>There’s a new standard out, <a href="https://www.rfc-editor.org/rfc/rfc9325">RFC 9325</a>, with guidelines on secure use of TLS. This short post will explain some of the history behind it and why you might want to explore this document.</em></p>

<p>In early 2013, we <a href="https://datatracker.ietf.org/doc/html/draft-sheffer-tls-bcp-00">started working</a> on a set of guidelines for Transport Layer Security (TLS) deployments. TLS is the security protocol that underlies much of today’s internet. In fact, almost all web pages today are served over HTTPS, which means the HTTP protocol is layered on top of TLS. Many years ago, the same protocol was called Secure Socket Layer or SSL, and this is the name many people still use to refer to TLS.</p>

<p>Back in 2013, TLS was in crisis. It was becoming increasingly clear that the internet needed to move into a fully encrypted model, especially after the <a href="https://www.theguardian.com/us-news/the-nsa-files">Snowden revelations</a> in mid-2013. TLS was the obvious technology to do the job. But the most commonly deployed TLS version was still overwhelmingly <a href="https://www.rfc-editor.org/rfc/rfc2246.html">TLS 1.0</a>, a 14-year-old protocol. Even though a major upgrade, TLS 1.2, had been <a href="https://www.rfc-editor.org/rfc/rfc5246">standardized</a> in 2008. On top of that, a <a href="https://www.rfc-editor.org/rfc/rfc7457">bunch of attacks</a> on the TLS protocol were being discovered on a regular basis, some of them limited to TLS 1.0 and others applying to the most up-to-date deployments.</p>

<p>The TLS community finally mobilized. Browser and server vendors and standards bodies such as the <a href="https://www.ietf.org/">IETF</a> worked together to (1) increase adoption of TLS 1.2, (2) ensure that TLS 1.2 is used securely, and (3) come up with a successor for TLS 1.2, namely TLS 1.3.</p>

<p><a href="https://www.rfc-editor.org/rfc/rfc7525.html">RFC 7525</a>, published in 2015, is a “best current practices” document that goes into the technical details of what a secure deployment of TLS 1.2 actually means. It covers a lot of ground, including TLS version negotiation, allowed and disallowed ciphersuites (cryptographic algorithms), TLS features like renegotiation and session resumption, and a lot more. It is not the only document that makes recommendations on the secure use of TLS, but it is very comprehensive and was published by the IETF, the same standards organization that defines the protocol itself. As a result, this document has been an important catalyst for the industry adoption of TLS 1.2 and the move to more secure TLS configurations.</p>

<p>Then the IETF went on to create a brand new version of TLS, <a href="https://www.rfc-editor.org/rfc/rfc8446">TLS 1.3</a>. This version is very different from TLS 1.2 and is a lot more secure. In fact, at some point, there was debate around whether it should be named TLS 2.0, and perhaps it should have been. Version numbers aside, TLS 1.3 (published in 2018) was adopted much more quickly than previous versions.</p>

<p>So, here we are today: TLS 1.0 and 1.1 are dead, for all intents and purposes. TLS 1.2 is still important, with roughly 40% of internet traffic still reliant on it. The majority of traffic has migrated to TLS 1.3. The situation is so different from what it was in 2015 that we felt a new set of guidelines is required, coming in the form of the brand new <a href="https://www.rfc-editor.org/rfc/rfc9325">RFC 9325</a>.</p>

<p>RFC 9325 provides guidance on the use of TLS 1.2 and 1.3. (Spoiler: TLS 1.2 is a <strong>MUST</strong> while 1.3 is still only a <strong>SHOULD</strong> because the IETF cares greatly about interoperability.) There’s the old stuff about TLS 1.2 ciphersuites dos and don’ts. This is largely irrelevant if you’re only using TLS 1.3, which has but a few ciphersuites that are all top-notch, but many new systems still rely on TLS 1.2.</p>

<p>Since 2015, there have been a few new attacks on TLS 1.2, though not as many as in the bad old days. The good news is that attack <em>names</em> are getting <a href="https://alpaca-attack.com/">better and better</a>. These new attacks are documented in the new RFC, and mitigations are suggested.</p>

<p>TLS 1.3 is not perfect either, with the 0-RTT feature widely seen as dangerously trading off security for performance (fast connection setup). Here the RFC only needed to <a href="https://www.rfc-editor.org/rfc/rfc9325#section-3.10">cite the warning</a> from the document that defines TLS 1.3.</p>

<p>Sadly, the situation around certificate revocation is still murky due to a lot of conflicting standards, some with minimal industry support. The document bravely wades into these waters and comes up with a <a href="https://www.rfc-editor.org/rfc/rfc9325#section-7.5">general recommendation</a>.</p>

<p>We incorporated recent work done at the <a href="https://datatracker.ietf.org/rg/cfrg/about/">CFRG</a> on cipher limits — how much data one is allowed to encrypt with each particular cipher before security is impacted. The limits are high but still reachable with a long-lived connection on a high-bandwidth network. If this is your network, please review <a href="https://www.rfc-editor.org/rfc/rfc9325#section-4.4">Section 4.4</a> to make sure you rekey your connections often enough.</p>

<p>The <a href="https://www.rfc-editor.org/rfc/rfc9325#section-8">bibliography</a> consists of 98 entries and spans 20+ years across multiple domains — basic math and crypto, protocol and software vulnerability research, standardization, and implementation experience.  We tried hard to distill that huge pile of information into simple and actionable text.</p>

<p>Moving forward, there is always new work being done to improve the security of the internet. The TLS working group is developing an <a href="https://datatracker.ietf.org/doc/draft-ietf-tls-esni/">Encrypted Client Hello</a> spec whose goal is to eliminate the cleartext Server Name Indication (SNI) field that’s heavily used in TLS but is a privacy hazard. This work is not ready yet, i.e., it is not yet published as an RFC, but keep an eye out!</p>

<p>We would like to thank the many IETF folks who passionately debated every last point in this document. It would be worthwhile if we improved, even a little, the security of everyone’s internet.</p>]]></content><author><name>Yaron Sheffer</name></author><category term="ietf" /><category term="TLS" /><summary type="html"><![CDATA[Yaron Sheffer, Peter Saint-Andre and Thomas Fossati]]></summary></entry><entry><title type="html">Certificate Delegation with ACME and STAR Certificates</title><link href="https://www.sheffer.org/blog/ietf/acme/star/2021/10/05/ACME-STAR.html" rel="alternate" type="text/html" title="Certificate Delegation with ACME and STAR Certificates" /><published>2021-10-05T11:00:18+03:00</published><updated>2021-10-05T11:00:18+03:00</updated><id>https://www.sheffer.org/blog/ietf/acme/star/2021/10/05/ACME-STAR</id><content type="html" xml:base="https://www.sheffer.org/blog/ietf/acme/star/2021/10/05/ACME-STAR.html"><![CDATA[<p>In early March 2020, just as the world was bracing for the COVID-19 pandemic, my co-authors and I published <a href="https://www.rfc-editor.org/rfc/rfc8739.html">RFC 8739</a>. This new standard introduced the concept of <strong>short-term, automatically renewed (STAR)</strong> certificates into the X.509 certificate universe, and specifically to the large and vibrant <a href="https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment">ACME</a> ecosystem. A year and a half later, we followed that with the publication of <a href="https://www.rfc-editor.org/rfc/rfc9115.html">RFC 9115</a> which builds on the ACME and STAR foundations to enable automated, easy to manage certificate delegation.</p>

<p>ACME is an open protocol for automated management of public-key certificates. It underlies the free and  hugely successful Let’s Encrypt certificate authority (CA) and is now being adopted by commercial CAs as well. ACME enables to automatically order, renew and revoke certificates using a simple REST API, and there are many open source tools based on this API that make it easily usable by administrators of web servers. By making certificates free and easy to obtain, Let’s Encrypt played a central role in the transition of the web to encrypted-by-default.</p>

<p>As noted, RFC 8739 defines short-term, automatically renewable certificates in the framework of ACME. If you’re not familiar with this concept, you might want to go back to the <a href="https://yaronf.svbtle.com/just-published-short-term-certificates-acme">blog post</a> we published at the time. But in short, these are totally standard X.509 public key certificates that are issued for a short duration (think 24 hours). The CA is instructed to issue a series of certificates, and it keeps on issuing them periodically, with the web server pulling them automatically at the same frequency. Remember that a certificate without its private key is completely public, and so the server can easily retrieve it from the CA, with no special security required, and start using the certificate to protect HTTPS traffic. ACME STAR is still young, but it has already been implemented by <a href="https://gitlab.com/platynum/certification-authority/flows">servers</a> and <a href="https://github.com/shred/acme4j/blob/master/src/doc/docs/usage/order.md">clients</a>.</p>

<p>The concept of short-term certificates allows for simpler deployment of Public Key Infrastructure (PKI) without the need and ongoing operational costs of certificate revocation. So in essence, STAR can be considered an optimization of the standard PKI framework. In contrast, RFC 9115 takes ACME to entirely new use cases by supporting <em>delegation</em> of public key certificates.</p>

<p>Imagine a large financial institution with global customer reach. The organization needs to deploy its web presence across many countries, ensuring good performance to all customers, regardless of where they may be located. Sounds difficult, but this is actually a solved problem, with the solution provided by <a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content Delivery Networks</a>, or CDNs. Obviously, this company’s web traffic is protected by TLS, with a certificate for <em>verybigbank.com</em>. Now consider the security implications: if the CDN is to terminate TLS connections on behalf of the company (its customer), it needs to present the certificate to TLS clients and more critically, it needs to keep a copy of the associated private key! The large company needs to trust the CDN with its private key, which may be used for other security functions beyond protection of web traffic. If at some point the company terminates its relationship with the CDN, it might try to revoke the certificate it handed over to the CDN (assuming a separate private key for the company’s in-house servers vs. the CDN), but for many reasons, certificate revocation is extremely unreliable in today’s Internet.</p>

<p>These issues are exacerbated by the practice of traffic outsourcing, where a top-level CDN hands the responsibility to one or more subordinate CDNs, in order to get better and more cost effective global coverage. As far as the company (again, the CDN’s customer) is concerned, the result is a hierarchy of CDNs, some of which may not even be known to the customer!</p>

<p>Another important scenario for certificate delegation is related to the lifecycle of virtual functions of whatever nature: virtual machines, containers, unikernels… This is especially applicable to edge environments, where instances of a concrete function may be scaled or migrated at a high rate, depending on traffic load or user mobility. Trust relationships would require certificates that are associated to a particular identifier, but cloning private keys as the virtual function footprint grows or moves does not seem the safest practice. The STAR delegation mechanism can support this highly dynamic lifecycle management without stretching too much the service trust fabric.</p>

<p>The problem of revocation is solved quite elegantly by using STAR certificates. The new RFC combines STAR with a profile of the ACME protocol that runs between the Delegate (the CDN or the function instances in the above examples) and the Identity Owner (the customer in the CDN example, the function identity in the edge case). See the figure below for a highly simplified description of the sequence of operations between the Delegate, the Identity Owner and the ACME CA.</p>

<p><img src="/assets/star-seq.png" alt="Image" /></p>

<p>So with the combination of the STAR and the ACME Delegation RFCs, we now have a handy solution to the problem of certificate delegation with a bunch of useful properties:</p>

<ul>
  <li>All certificate issuance is controlled by the customer. The customer is aware of all certificates being issued, can revoke any of them, and can control the exact details (key usage, extension fields) of each certificate. More precisely, the customer can revoke a <em>sequence</em> of certificates, meaning it can stop the CA from issuing new ones.</li>
  <li>Private keys are segregated between the customer and each of the CDNs. Each certificate can be revoked without affecting the others.</li>
  <li>The protocol can be deployed “recursively”, through a chain of proxies. This accounts for CDN hierarchies, with each CDN only directly accessing the CDNs with which it has a direct commercial relationship, or to a chain of edge platform providers.</li>
  <li>Both RFCs are relatively small extensions to the well tested and widely implemented ACME protocol.</li>
  <li>Critically, the certificates are all standard X.509, and are understood by any TLS client out there. All the magic happens in the “back end”: between the certificate owner, the certificate issuer, and the delegate that owns the web server. While this requirement for backward compatibility may sound trivial, it is not true of other protocols in the space of certificate delegation.</li>
</ul>

<p>Finally, I would like to thank co-authors for all the hard work that went into this standard: <strong>Diego López</strong>, <strong>Antonio Agustín Pastor Perales</strong> and <strong>Thomas Fossati</strong>, as well as the ACME working group members and its chairs. It has taken a long time, five years since the initial LURK discussion, and we are proud of the results and looking forward to see them used across the industry.</p>]]></content><author><name>Yaron Sheffer</name></author><category term="ietf" /><category term="ACME" /><category term="STAR" /><summary type="html"><![CDATA[In early March 2020, just as the world was bracing for the COVID-19 pandemic, my co-authors and I published RFC 8739. This new standard introduced the concept of short-term, automatically renewed (STAR) certificates into the X.509 certificate universe, and specifically to the large and vibrant ACME ecosystem. A year and a half later, we followed that with the publication of RFC 9115 which builds on the ACME and STAR foundations to enable automated, easy to manage certificate delegation.]]></summary></entry><entry><title type="html">Short Term Certificates in ACME: A New Alternative to Revocation</title><link href="https://www.sheffer.org/blog/ietf/acme/2020/03/11/ACME.html" rel="alternate" type="text/html" title="Short Term Certificates in ACME: A New Alternative to Revocation" /><published>2020-03-11T10:00:18+02:00</published><updated>2020-03-11T10:00:18+02:00</updated><id>https://www.sheffer.org/blog/ietf/acme/2020/03/11/ACME</id><content type="html" xml:base="https://www.sheffer.org/blog/ietf/acme/2020/03/11/ACME.html"><![CDATA[<p>My coauthors and I just published <a href="https://www.rfc-editor.org/rfc/rfc8739.html">RFC 8739</a> on <strong>Short-Term, Automatically Renewable (STAR)</strong> certificates in the ACME <a href="https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment">automated certificate management</a> protocol. This post explains what STAR certificates are, why we see them as an essential next step for the global public key infrastructure (PKI) and how they are enabled by the new ACME protocol.</p>

<p><img src="/assets/acme-protocol.png" alt="ACME–protocol-icon.png" /></p>

<p>Some RFCs published by the IETF are fixes for well established technologies. This is true for my own <a href="https://tools.ietf.org/html/rfc7525">TLS Best Current Practices</a> and the more recent <a href="https://www.rfc-editor.org/rfc/rfc8725.html">JWT BCP</a>. In contrast, the STAR RFC aims to kickstart new technology that we see as essential to the new ways applications are being deployed. To see why, we need to dive into the theory – and the very different practice – of PKI.</p>

<p>If you’ve only learned the theory of public key infrastructure in school, you could be forgiven for having a traditional view of the certificate lifecycle:</p>

<ul>
  <li>Certificates are issued with long validity periods, often one or two years.</li>
  <li>Certificates are obtained manually, by going to the Certificate Authority’s (CA) web page and presenting a credit card.</li>
  <li>Certificates are installed manually on the web server, leading to frequent cases when people forget to deploy the new certificate on time, and the server ends up “bricked”.</li>
  <li>Revocation is through Certificate Revocation Lists (CRLs) that include all certificates that have been revoked by a certain CA.</li>
  <li>The relying party can validate the certificate off-line, by only looking at the certificate itself, and possibly at revocation information that’s typically already stored in a local cache.</li>
</ul>

<p>Surprise! Except for the first assumption, all others on this list are no longer valid in today’s environment…</p>

<ul>
  <li>With the ACME protocol, certificates are fetched from the CA automatically, after the client proves it is authorized for the identity being asserted. Then, they are installed automatically. In fact the default frequency of certificate renewal which is 90 days means that any sane deployment is fully automated.</li>
  <li>CRLs are rarely used because they tend to grow into unmanageable sizes. When certificates absolutely need to be distrusted, this is typically done through a <a href="https://www.futurehosting.com/blog/why-dont-browsers-use-certificate-revocation-checking/">software update</a> to browsers.</li>
  <li>The best practice is for certificates to be issued with an <a href="https://en.wikipedia.org/wiki/Online_Certificate_Status_Protocol">OCSP</a> endpoint, and for the relying party to consult the OCSP server before deciding to trust the certificate.</li>
</ul>

<p>The STAR work aims to do away with the one remaining “old world” assumption, that of long validity periods.</p>

<h2 id="the-star-certificates-lifecycle">The STAR Certificate’s Lifecycle</h2>

<p>Similarly to the shift from servers to containers (the <a href="http://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/">Pets vs. Cattle</a> analogy), STAR certificates are not managed individually. When a web site needs to be protected with STAR certificates, an ACME <em>Certificate Order</em> is created. This step can be done with a CLI and can of course itself be automated. In the case of STAR, an ACME Order corresponds to a sequence of short-term certificates, perhaps a hundred or more. When creating this initial Order, the requestor needs to generate a private key and include a traditional Certificate Signing Request (<a href="https://en.wikipedia.org/wiki/Certificate_signing_request">CSR</a>).</p>

<p>Each of the certificates included in a STAR Order is valid for a short duration, say 72 hours, and they are issued sequentially. Halfway through the lifetime of each certificate, an agent installed on the web server goes off and fetches the next certificate from a highly available API endpoint on the Certificate Authority, also known as the ACME Server.</p>

<p>Remember that the certificate itself is not secret, so there’s no harm in making it openly available for anyone to pull. Of course, only the owner can make any use of it because only the owner has the corresponding private key.</p>

<p>This somewhat added complexity on the web server’s side pays off with great simplification on the client side: a client that needs to validate a STAR certificate is suddenly back to the good old days: there is no longer any need to query and cache CRLs, and no need for on-line validation with an OCSP server. The results are obvious: better performance, simplified and less error prone code paths, and because of the elimination of the on-line check, higher reliability.</p>

<p>A side effect of this solution is a significantly higher load on the Certificate Transparency (<a href="https://en.wikipedia.org/wiki/Certificate_Transparency">CT</a>) infrastructure, which stores a copy of each publicly issued certificate. We spoke with the CT community and concluded that CT is scalable enough to cope with this extra load.</p>

<p>We just went through the happy path, where the certificate is valid and the client successfully establishes a connection. But what if the server is suspected to have been breached, and the certificate needs to be revoked? One REST call to the ACME server and the Order is cancelled, which means that no further certificates would be issued. As soon as the current certificate expires, the server will not be able to present a valid certificate for the private key it is holding and connection attempts will fail. There’s a bit of a subtlety here: revocation is not immediate, it only takes place when the newest current certificate expires. But in fact, due to caching effects revocation has <em>never</em> been immediate for CRLs and OCSP either. The recommended STAR certificate lifetimes were specified to be similar to the caching time frames for these older technologies.</p>

<h2 id="star-certificates-enable-delegation">STAR Certificates Enable Delegation</h2>

<p>Beyond just simplifying the common use case, STAR certificates enable entirely new use cases. The fact that revocation is easy and effective means that the private key can be handed to a less-than-fully-trusted entity and revoked as necessary. Think of a Content Delivery Network (CDN) which you want to present your web site’s data, but under the provision that this authority can be revoked at any moment. Or think of a large deployment of containers. Each HTTPS endpoint can hold its own private key, associated with a sequence of certificates, and those can be generated automatically and revoked on demand, also automatically.</p>

<p>Moreover, this can be done with no added latency (unlike the <a href="https://github.com/mglt/pylurk">LURK proposal</a>) and without the major pain of client-side migration, which is the case in the <a href="https://datatracker.ietf.org/doc/draft-ietf-tls-subcerts/">delegated credentials proposal</a>, now being advanced by the TLS working group.</p>

<p>We are now working on a follow-on specification of <a href="https://datatracker.ietf.org/doc/draft-ietf-acme-star-delegation/">STAR certificate delegation</a>, and you can follow its progress at the IETF <a href="https://datatracker.ietf.org/wg/acme/about/">ACME working group</a>.</p>

<p>To summarize, support for STAR certificates is a major new PKI capability enabled by the new ACME ecosystem. It comes with important short term benefits and promises longer term benefits that will help deploy TLS securely in ever more use cases.</p>

<hr />

<p>Finally, I would like to thank my co-authors: Diego Lopez, Oscar Gonzalez de Dios, Antonio Agustin Pastor Perales and most of all, Thomas Fossati. Every RFC is a journey, and this one was made truly enjoyable by our partnership.</p>]]></content><author><name>Yaron Sheffer</name></author><category term="IETF" /><category term="ACME" /><summary type="html"><![CDATA[My coauthors and I just published RFC 8739 on Short-Term, Automatically Renewable (STAR) certificates in the ACME automated certificate management protocol. This post explains what STAR certificates are, why we see them as an essential next step for the global public key infrastructure (PKI) and how they are enabled by the new ACME protocol.]]></summary></entry><entry><title type="html">Identity Pinning: A New Approach to Certificate Validation</title><link href="https://www.sheffer.org/blog/ietf/2019/10/31/ID-Pinning.html" rel="alternate" type="text/html" title="Identity Pinning: A New Approach to Certificate Validation" /><published>2019-10-31T10:00:18+02:00</published><updated>2019-10-31T10:00:18+02:00</updated><id>https://www.sheffer.org/blog/ietf/2019/10/31/ID-Pinning</id><content type="html" xml:base="https://www.sheffer.org/blog/ietf/2019/10/31/ID-Pinning.html"><![CDATA[<h2 id="just-published-rfc-8672-on-server-identitypinning---a-modern-lightweight-alternative-to-certificate-pinning">Just Published: RFC 8672 on Server Identity Pinning  – a modern, lightweight alternative to certificate pinning</h2>

<p>The RFC Editor just published <a href="https://www.rfc-editor.org/rfc/rfc8672.html">RFC 8672</a>, a specification that can potentially make TLS deployments much more secure by virtually eliminating the risk of forged public-key certificates.</p>

<p>For many years we have been seeing <a href="https://threatpost.com/final-report-diginotar-hack-shows-total-compromise-ca-servers-103112/77170/">attacks</a> on certificate authorities (CAs). All CAs are essentially created equal, and if a rogue CA issues a certificate for <em>example.com</em> and hands it to a malicious server, there’s nothing to stop clients from connecting to the server and trusting its identity. The same is true for servers located behind enterprise firewalls. A rogue CA could just as well issue a fake certificate for <em>finance-dept.example.com</em>, regardless of whether it can access the server or not.</p>

<p>An often used approach within enterprise networks is <em>certificate pinning</em>. Normally we trust a server certificate because it is the last component of a certificate chain: a chain that starts with CAs that are widely known, and are configured into the TLS client (the browser, typically), contains one or two lesser “intermediate” CAs, and ends with the server certificate. Each of these chained certificates is digitally signed by the one above it.</p>

<p><img src="/assets/pinning-pins.jpg" alt="pins-1358849_800.jpg" />
<em>Photo: Brett Hondow, Pixabay</em></p>

<p>Certificate pinning, the solution that we are replacing, forgoes the certificate chain in favor of direct trust in the server’s certificate, which is stored in the client’s certificate store. Unfortunately, certificate pinning is a management nightmare: every time the server’s certificate is reissued – typically once a year – all clients need to be updated with the new certificate. A variant of this approach is to pin the CA, instead of the server certificate, by having all clients remember that the certificate for <em>example.com</em> must only be issued by <em>my-favorite-ca.com</em>. This works quite well… until the company decides to migrate to <em>cheaper-ca.com</em>. Then, all clients need to be updated with the new CA, a major pain. For this reason and others, <a href="https://tools.ietf.org/html/rfc7469">internet standards</a> for certificate pinning <a href="https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead">have not seen</a> wide deployment.</p>

<p>In an attempt to simplify this solution, we came up with the identity pinning notion, based on the <a href="https://en.wikipedia.org/wiki/Trust_on_first_use">Trust-on-First-Use (TOFU)</a> principle:</p>

<p>The first time a client connects to a server, they both compute a secret value based on the TLS handshake. The server sends back to the client an opaque (encrypted) ticket that contains this secret. The client that already computed the secret independently, stores the ticket along with the secret for future use. Note the trust-on-first-use element here: the server authenticates itself the good old fashioned way, using only its certificate.</p>

<p><img src="/assets/pinning-seq1.png" alt="Pinning_ Initial Connection.png" />
<em>Initial Connection</em></p>

<p>On any subsequent connection, the client sends the ticket to the server. Only the genuine server is able to decrypt the ticket, obtain the secret and send back a proof that indeed, it knows the secret. The client now verifies the proof. If the proof is correct, the TLS handshake completes successfully and the connection is established. Otherwise, <em>poof</em>  –  the TLS handshake is aborted.
<img src="/assets/pinning-seq2.png" alt="Pinning_ Subsequent Connection.png" />
<em>Subsequent Connection (Simplified)</em></p>

<p>What we have gained is <em>second-factor authentication for the server</em>. The TLS server not only needs to present a valid certificate, as usual, it also needs to prove that it possesses the secret that’s needed to decrypt the ticket, proving its legitimacy.</p>

<p>This all happens automatically with no need to configure anything, either on the client or the server side. It is also independent of the server’s certificate (hence <em>identity pinning</em>), which eliminates the complexity inherent in certificate pinning solutions. </p>

<p>You may want to <a href="https://www.rfc-editor.org/rfc/rfc8672.html">read the RFC</a> for the lowdown on this protocol. We learned from other people’s experience, and the protocol has quite a few <strong>features</strong> that make it attractive for real-life use:</p>

<ul>
  <li><strong>Generality</strong>: identity pinning works at the TLS level, with no dependence on HTTP or assumptions on traffic. It can be applied to web traffic on the internet and within the enterprise, to REST APIs, and to non-HTTP protocols. </li>
  <li><strong>Zero management</strong>: nothing needs to be configured on the client side. On the server side there is only one simple parameter: the ticket lifetime (normally between 7 and 31 days).</li>
  <li><strong>Robustness</strong>: the protocol is not effected by certificate renewal, CA change or even certificate revocation, and can accommodate single servers and server clusters alike.</li>
  <li><strong>Very low overhead</strong>: the ticket and additional TLS messages are very small. The client maintains a “pin store” that holds a few dozen bytes for each server it has seen in the last month.</li>
  <li><strong>Up to date</strong>: the protocol is defined for TLS 1.3 which, in late 2019, is quite new but already widely deployed.</li>
</ul>

<p><img src="/assets/pinning-tls13.png" alt="tls13.png" /></p>

<ul>
  <li><strong>Privacy</strong>: servers are required to regenerate a new ticket on each connection, so that tickets cannot be used by an eavesdropper to link different sessions by the same client.</li>
  <li><strong>Deployment flexibility</strong>: the protocol includes a “ramp down” mode, in case a server owner decides to disable the use of this mechanism.</li>
  <li><strong>Best fit to enterprise networks</strong>: whereas servers on the open internet can benefit from <a href="https://www.certificate-transparency.org/">Certificate Transparency</a>, servers located “behind the firewall” typically do not have their certificates stored in the CT infrastructure. Identity Pinning is a simple way to harden such servers’ secure connectivity.</li>
</ul>

<p>We have <a href="https://github.com/yaronf/mint">implemented</a> the Identity Pinning protocol but due to the slow pace of standardization, the implementation is somewhat outdated by now. If you plan to implement the protocol, feel free to reach out to <a href="mailto:draft-sheffer-tls-pinning-ticket@ietf.org">the authors (Daniel Migault and myself)</a> with any questions.</p>]]></content><author><name>Yaron Sheffer</name></author><category term="ietf" /><summary type="html"><![CDATA[Just Published: RFC 8672 on Server Identity Pinning – a modern, lightweight alternative to certificate pinning]]></summary></entry></feed>